function [predLoc, predForce, x_P, tauext_est_mean] = LocIsol_particleFilter_red(trigger, Tauext, predBody, q, dq, x, dx, Jinv_hqx_ind, J_hredxqa, n_particle, param)
    
    persistent x_P_est
    
    if predBody == 2 
        pred_chain = 1; 
    elseif predBody == 4 
        pred_chain = 2; 
    elseif predBody == 6 
        pred_chain = 3; 
    else
        predLoc = 0;
        predForce = 0;
        x_P = zeros(n_particle,2);
        tauext_est_mean = zeros(3,1);
        return
    end
    
    if isempty(x_P_est)||trigger
        x_P_est = init_particleFilter(n_particle);
    end
    
    pred_link = 2;
    qa = q([1 4 7]);
    qp = q([2 5 8]);
    qseg = qa(pred_chain) + param.psi_j(pred_chain)+qp(pred_chain);    
    R_0Gj = [cos(qseg) -sin(qseg) 0 ; sin(qseg) cos(qseg) 0 ;0 0 1]; 
    z=Tauext;
    x_P_update=nan(n_particle,2);
    z_update=nan(n_particle,3);
    P_w=nan(1,n_particle);
    for k = 1:n_particle
        %given the prior set of particle (i.e. randomly generated locations
        %the quail might be), run each of these particles through the state
        %update model to make a new set of transitioned particles.
        x_P_update(k,1) = (x_P_est(k,1) + sqrt(param.x_N_2D(1))*randn);
        x_P_update(k,2) = (x_P_est(k,2) + sqrt(param.x_N_2D(2))*randn);
        %with these new updated particle locations, update the observations
        %for each of these particles.
        jj = x_P_update(k,1);
        [~, ~, ~, Jac_xpq, ~, ~, ~, ~,~, ~]... 
        = calcJac_colSeg(pred_link, q, dq, x, dx, param.l_all, param.r_BasisPla_MobPla, ...
                         param.l_all_id, param.r_fixPlat_j, param.r_mobPlat_j, pred_chain,...
                         jj, 0); 
        Jac_xpx = Jac_xpq*Jinv_hqx_ind;
        Jac_xpqa = Jac_xpx*J_hredxqa;
        Jac_xpqa_t = Jac_xpqa';

        Fextlink_KS0 = R_0Gj(1:2,1:2)* [0;x_P_update(k,2)];
        z_update(k,:) = (Jac_xpqa_t(:,1:2)*Fextlink_KS0); 
        %Generate the weights for each of these particles.
        %The weights are based upon the probability of the given
        %observation for a particle, GIVEN the actual observation.
        %That is, if we observe a location z, and we know our observation error is
        %guassian with variance x_R, then the probability of seeing a given
        %z centered at that actual measurement is (from the equation of a
        %gaussian)
        P_wtmp = 1; % Da Gewichte später normiert werden, hat diese Größe keinen Einfluss
        P_w(k) = P_wtmp * exp(-0.5*(z-z_update(k,:)')'*param.x_CovR_Inv_2D*(z-z_update(k,:)'));
    end

        % Normalize to form a probability distribution (i.e. sum to 1).
        P_w = P_w./sum(P_w);

        % Resampling: From this new distribution, now we randomly sample from it to generate our new estimate particles
        %what this code specifically does is randomly, uniformally, sample from
        %the cummulative distribution of the probability distribution
        %generated by the weighted vector P_w.  If you sample randomly over
        %this distribution, you will select values based upon there statistical
        %probability, and thus, on average, pick values with the higher weights
        %(i.e. high probability of being correct given the observation z).
        %store this new value to the new estimate which will go back into the
        %next iteration

%         indx = find( rand <= cumsum(P_w),1)*ones(size(x_P,1),1);
%         indx = resampleMultinomial(P_w);
%         indx = resampleResidual(P_w);    
%         indx = resampleStratified(P_w);
        indx = resampleSystematic(P_w);
        x_P_est = x_P_update(indx,:);

        %The final estimate is some metric of these final resampling, such as
        %the mean value or variance
        x_P=x_P_est;
        x_mean = mean(x_P_est);
        [~, ~, ~, Jac_xpq_mean, ~, ~, ~, ~,~, ~]... 
        = calcJac_colSeg(pred_link, q, dq, x, dx, param.l_all, param.r_BasisPla_MobPla, ...
                         param.l_all_id, param.r_fixPlat_j, param.r_mobPlat_j, pred_chain,...
                         x_mean(1), 0); 
        Jac_xpx_mean = Jac_xpq_mean*Jinv_hqx_ind;
        Jac_xpqa_mean = Jac_xpx_mean*J_hredxqa;
        Jac_xpqa_t_mean = Jac_xpqa_mean';        
        tauext_est_mean = (Jac_xpqa_t_mean(:,1:2)*R_0Gj(1:2,1:2)* [0;x_mean(2)]); 
%         x_mean = P_w'*x_P;
        predLoc=x_mean(1);
        predForce=x_mean(2);
end

function x_P = init_particleFilter(N)
    % make the randomly generated particles from the initial prior gaussian distribution
    x_P=nan(N,2);
    for i = 1:N
            x_P(i,1) = unifrnd(0,1);
            x_P(i,2) = unifrnd(-40,40);
    end
end


function [ indx ] = resampleMultinomial( w )
    indx = zeros(size(w));
    M = length(w);
    Q = cumsum(w);
    Q(M)=1; % Just in case...
    i=1;
    while (i<=M)
        sampl = rand(1,1);  % (0,1]
        j=1;
        while (Q(j)<sampl)
            j=j+1;
        end
        indx(i)=j;
        i=i+1;
    end
end

function [ indx ] = resampleResidual( w )
    indx = zeros(size(w));
    M = length(w);
    % "Repetition counts" (plus the random part, later on):
    Ns = floor(M .* w);
    % The "remainder" or "residual" count:
    R = sum( Ns );
    % The number of particles which will be drawn stocastically:
    M_rdn = M-R;
    % The modified weights:
    Ws = (M .* w - floor(M .* w))/M_rdn;
    % Draw the deterministic part:
    % ---------------------------------------------------
    i=1;
    for j=1:M
        for k=1:Ns(j)
            indx(i)=j;
            i = i +1;
        end
    end
    % And now draw the stocastic (Multinomial) part:
    % ---------------------------------------------------
    Q = cumsum(Ws);
    Q(M)=1; % Just in case...
    while (i<=M)
        sampl = rand(1,1);  % (0,1]
        j=1;
        while (Q(j)<sampl)
            j=j+1;
        end
        indx(i)=j;
        i=i+1;
    end
end

function indx = resampleStratified(w)
    indx = zeros(size(w));
    N = length(w);
    Q = cumsum(w);
    for i=1:N
        T(i) = rand(1,1)/N + (i-1)/N;
    end
    T(N+1) = 1;
    i=1;
    j=1;
    while (i<=N)
        if (T(i)<Q(j))
            indx(i)=j;
            i=i+1;
        else
            j=j+1;        
        end
    end
end

function indx = resampleSystematic(w)
    indx = zeros(size(w));
    N = length(w);
    Q = cumsum(w);
    T = linspace(0,1-1/N,N+1) + rand(1)/N;
    T(N+1) = 1;
    i=1;
    j=1;
    while (i<=N)
        if (T(i)<Q(j))
            indx(i)=j;
            i=i+1;
        else
            j=j+1;        
        end
    end
end
